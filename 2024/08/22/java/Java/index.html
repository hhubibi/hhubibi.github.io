<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/apple-touch-icon.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.6.0/css/all.min.css" integrity="sha256-5eIC48iZUHmSlSUz9XtjRyK2mzQkHScZY1WdMaoz74E=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"hhubibi.github.io","root":"/","images":"/images","scheme":"Mist","darkmode":false,"version":"8.21.1","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="什么是反射？为什么要反射？反射怎么实现的？为什么反射效率低？怎么提高反射的效率？什么是反射？Java的反射是在程序运行时动态地加载类并获取类的详细信息，从而操作类的方法和字段。本质上是通过获得Class对象之后，再通过class对象进行反编译，从而获取对象的各种信息。反射的包基本在java.lang.reflect.*下。为什么要反射？因为Java需要先编译再运行，程序中对象的类型在编译的时候就">
<meta property="og:type" content="article">
<meta property="og:title" content="面经">
<meta property="og:url" content="http://hhubibi.github.io/2024/08/22/java/Java/index.html">
<meta property="og:site_name" content="The Why Cafe">
<meta property="og:description" content="什么是反射？为什么要反射？反射怎么实现的？为什么反射效率低？怎么提高反射的效率？什么是反射？Java的反射是在程序运行时动态地加载类并获取类的详细信息，从而操作类的方法和字段。本质上是通过获得Class对象之后，再通过class对象进行反编译，从而获取对象的各种信息。反射的包基本在java.lang.reflect.*下。为什么要反射？因为Java需要先编译再运行，程序中对象的类型在编译的时候就">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://hhubibi.github.io/%E9%9D%A2%E8%AF%95/%E7%B1%BB%E5%88%9D%E5%A7%8B%E5%8C%96%E7%9A%84%E9%A1%BA%E5%BA%8F.png">
<meta property="og:image" content="http://hhubibi.github.io/%E9%9D%A2%E8%AF%95/JVM%E5%86%85%E5%AD%98JDK7.png">
<meta property="og:image" content="http://hhubibi.github.io/%E9%9D%A2%E8%AF%95/JVM%E5%86%85%E5%AD%98JDK8.png">
<meta property="og:image" content="http://hhubibi.github.io/%E9%9D%A2%E8%AF%95/HashMap%E7%9A%84PUT.png">
<meta property="og:image" content="http://hhubibi.github.io/%E9%9D%A2%E8%AF%95/ConcurrentHashMap%20JDK7.png">
<meta property="og:image" content="http://hhubibi.github.io/%E9%9D%A2%E8%AF%95/ConcurrentHashMap%20JDK8.png">
<meta property="og:image" content="http://hhubibi.github.io/%E9%9D%A2%E8%AF%95/LinkedHashMap.png">
<meta property="og:image" content="http://hhubibi.github.io/%E9%9D%A2%E8%AF%95/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.png">
<meta property="og:image" content="http://hhubibi.github.io/%E9%9D%A2%E8%AF%95/threadlocal.png">
<meta property="og:image" content="http://hhubibi.github.io/%E9%9D%A2%E8%AF%95/ThreadLocal%E5%BC%BA%E5%BC%95%E7%94%A8.png">
<meta property="og:image" content="http://hhubibi.github.io/%E9%9D%A2%E8%AF%95/ThreadLocal%E5%BC%B1%E5%BC%95%E7%94%A8.png">
<meta property="og:image" content="http://hhubibi.github.io/%E9%9D%A2%E8%AF%95/G1%E6%B5%81%E7%A8%8B.png">
<meta property="article:published_time" content="2024-08-22T02:42:32.000Z">
<meta property="article:modified_time" content="2025-07-26T01:32:37.851Z">
<meta property="article:author" content="hhubibi">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://hhubibi.github.io/%E9%9D%A2%E8%AF%95/%E7%B1%BB%E5%88%9D%E5%A7%8B%E5%8C%96%E7%9A%84%E9%A1%BA%E5%BA%8F.png">


<link rel="canonical" href="http://hhubibi.github.io/2024/08/22/java/Java/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://hhubibi.github.io/2024/08/22/java/Java/","path":"2024/08/22/java/Java/","title":"面经"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>面经 | The Why Cafe</title><meta name="robots" content="noindex">
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">The Why Cafe</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BC%82%E5%B8%B8"><span class="nav-number">1.</span> <span class="nav-text">异常</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9B%86%E5%90%88"><span class="nav-number">2.</span> <span class="nav-text">集合</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88string%E5%92%8Cinteger%E6%98%AF%E4%B8%8D%E5%8F%AF%E5%8F%98%E7%9A%84%EF%BC%9F%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%8D%E5%8F%AF%E5%8F%98%E7%B1%BB%EF%BC%9F"><span class="nav-number">2.0.1.</span> <span class="nav-text">为什么string和integer是不可变的？什么是不可变类？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#hashSet%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%9F%A5%E9%87%8D%E7%9A%84%EF%BC%9F"><span class="nav-number">2.0.2.</span> <span class="nav-text">hashSet是如何实现查重的？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%AF%94%E8%BE%83-HashSet%E3%80%81LinkedHashSet-%E5%92%8C-TreeSet-%E4%B8%89%E8%80%85%E7%9A%84%E5%BC%82%E5%90%8C"><span class="nav-number">2.0.3.</span> <span class="nav-text">比较 HashSet、LinkedHashSet 和 TreeSet 三者的异同</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#arrayList%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%EF%BC%9F"><span class="nav-number">2.1.</span> <span class="nav-text">arrayList怎么实现线程安全？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B9%B6%E5%8F%91"><span class="nav-number">3.</span> <span class="nav-text">并发</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E6%96%B9%E5%BC%8F%EF%BC%9A"><span class="nav-number">3.1.</span> <span class="nav-text">创建方式：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%EF%BC%9A"><span class="nav-number">3.2.</span> <span class="nav-text">线程池的底层原理：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#reentrantLock%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%85%AC%E5%B9%B3%E9%94%81%E5%92%8C%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81%E7%9A%84%EF%BC%9F"><span class="nav-number">3.3.</span> <span class="nav-text">reentrantLock是如何实现公平锁和非公平锁的？</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#ThreadLocal%E7%9A%84set%E6%96%B9%E6%B3%95%EF%BC%9A"><span class="nav-number">3.3.1.</span> <span class="nav-text">ThreadLocal的set方法：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ThreadLocal%E7%9A%84get%E6%96%B9%E6%B3%95%EF%BC%9A"><span class="nav-number">3.3.2.</span> <span class="nav-text">ThreadLocal的get方法：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ThreadLocal%E7%9A%84remove%E6%96%B9%E6%B3%95%EF%BC%9A"><span class="nav-number">3.3.3.</span> <span class="nav-text">ThreadLocal的remove方法：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%87%BA%E7%8E%B0%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E7%9A%84%E5%89%8D%E6%8F%90%EF%BC%9A"><span class="nav-number">3.3.4.</span> <span class="nav-text">出现内存泄漏的前提：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AC%AC%E4%B8%80%E7%A7%8D%EF%BC%9ACountDownLatch%E9%85%8D%E5%90%88%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%9A"><span class="nav-number">3.3.5.</span> <span class="nav-text">第一种：CountDownLatch配合线程池：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AC%AC%E4%BA%8C%E7%A7%8D%EF%BC%9ACountDownLatch%E9%85%8D%E5%90%88future%E3%80%81%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%9A"><span class="nav-number">3.3.6.</span> <span class="nav-text">第二种：CountDownLatch配合future、线程池：</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6"><span class="nav-number">4.</span> <span class="nav-text">垃圾回收</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="nav-number">5.</span> <span class="nav-text">设计模式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F"><span class="nav-number">5.1.</span> <span class="nav-text">创建型模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F"><span class="nav-number">5.2.</span> <span class="nav-text">结构型模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F"><span class="nav-number">5.3.</span> <span class="nav-text">行为型模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BA%8F%E5%88%97%E5%8C%96"><span class="nav-number">5.4.</span> <span class="nav-text">序列化</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%B7%E4%BD%93%E8%BF%87%E7%A8%8B%EF%BC%9A"><span class="nav-number">5.4.1.</span> <span class="nav-text">具体过程：</span></a></li></ol></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">hhubibi</p>
  <div class="site-description" itemprop="description">Welcome to my lonely planet!</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">1</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://hhubibi.github.io/2024/08/22/java/Java/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="hhubibi">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="The Why Cafe">
      <meta itemprop="description" content="Welcome to my lonely planet!">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="面经 | The Why Cafe">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          面经
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-08-22 10:42:32" itemprop="dateCreated datePublished" datetime="2024-08-22T10:42:32+08:00">2024-08-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-07-26 09:32:37" itemprop="dateModified" datetime="2025-07-26T09:32:37+08:00">2025-07-26</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><ol>
<li><p>什么是反射？为什么要反射？反射怎么实现的？为什么反射效率低？怎么提高反射的效率？<br><strong>什么是反射？</strong><br><br>Java的反射是在程序运行时动态地加载类并获取类的详细信息，从而操作类的方法和字段。本质上是通过获得<strong>Class</strong>对象之后，再通过class对象进行反编译，从而获取对象的各种信息。<br>反射的包基本在java.lang.reflect.*下。<br><strong>为什么要反射？</strong><br><br>因为Java需要先编译再运行，程序中对象的类型在编译的时候就确定了。由于一些类因为之前用不到，所以JVM没有给他加载进来，而如果想在运行的时候动态地使用一些类，那就需要反射，反射不需要在编译期提前知道运行的对象是谁。</p>
<p>也就是说，如果我们在编译的时候知道类或对象的信息，则可以直接使用，而不需要反射。否则，则需要反射。</p>
<p><strong>优点：</strong><br><br>对于java这种先编译再运行的语言，可以很方便地创建灵活的代码。 比如配合配置文件，可以在不修改代码，只修改配置文件的情况下，完成对实现类的切换。<br><strong>缺点：</strong><br></p>
<ol>
<li>性能很低。JVM编译的时候无法对反射的代码进行优化，而且需要额外的检查，因此效率会低很多。</li>
<li>反射会跳过权限检查，导致安全风险。</li>
<li>会模糊程序内部的逻辑。</li>
</ol>
<p><strong>如何提高反射的效率？</strong><br><br>4. 不要使用getMethods()、getFields()这样的方法后再去遍历找，而是直接传入方法名methodName、字段名fieldName，直接获取。<br>5. 在本地增加缓存，保存Class对象，而不要每次都Class.forName()加载<br>6. 把反射变为直接调用，如CGLIB的FastClass，在方法和number之间建立数字索引。</p>
<p><strong>如何获得Class对象？</strong><br><br>7. 通过Class.forName()来得到类的class对象<br>8. 通过 对象.getClass()方法来得到类对象<br>9. 类型.class可以得到<br><strong>得到Class对象后，一般需要实例化类对象才能操作，所以怎么实例化？</strong><br><br>通过Class对象的newInstance()方法</p>
</li>
<li><p>什么是动态代理？JDK动态代理以及CGLIB的动态代理？<br>动态代理就是在程序运行期间，创建目标的代理对象，实现代理对象的功能增强的一种技术。</p>
<ol>
<li>JDK的动态代理</li>
</ol>
<ul>
<li>需要实现InvocationHandler接口，并重写invoke方法，三个参数，类加载器、传入的method以及方法的参数。</li>
<li>然后通过Proxy.newProxyInstance()来创建代理对象。它需要传入类加载器、代理对象实现的接口以及代理对象本身。</li>
</ul>
<p><strong>限制：</strong> JDK的动态代理只能代理实现了接口的类，其他的无法代理。</p>
<ol>
<li>CGLIB的动态代理<br>是通过修改字节码生成子类来实现的。它会继承被代理的类。<br>CGLIB的核心是 MethodInterceptor 接口和 Enhancer 类是核心。<ol>
<li>实现MethodIntercepter接口并重写方法，在方法内部对代理对象进行功能增强。</li>
<li>通过Enhancer来创建代理对象。</li>
</ol>
</li>
</ol>
<p>CGLIB是通过fastClass来实现的，就是为方法建立索引，根据索引来调用方法。<br><strong>限制：</strong> CGLIB由于是通过继承来实现代理的，所以不能对final修饰的类进行代理。</p>
<p>在Spring的AOP中，如果类实现了接口，则使用JDK的动态代理，否则使用CGLIB。一般来说，JDK的效率更高。</p>
</li>
<li><p>对象实例化的过程？<br></p>
<ol>
<li>类的加载过程：<ol>
<li>加载<ul>
<li>加载类的二进制字节流，可以从本地字节码中获取，也可以从网络中获取</li>
<li>把二进制字节流加载到内存中，会在堆中生成Class对象</li>
</ul>
</li>
<li>连接 <br><br>   连接分成了三部分：<ol>
<li>验证：验证二进制字节流的正确性</li>
<li>准备：为静态变量分配空间，为其赋默认值，final变量会直接赋程序中指定的值</li>
<li>解析：把符号引用转变为直接引用</li>
</ol>
</li>
<li>初始化<br>   初始化会执行静态代码块和<clinit>方法，这是由JVM自动创建的。<br>   由于非静态变量属于对象，不属于类，而类加载的几个阶段都只针对类变量，所以非静态变量是不会被初始化的。<br><img src="/%E9%9D%A2%E8%AF%95/%E7%B1%BB%E5%88%9D%E5%A7%8B%E5%8C%96%E7%9A%84%E9%A1%BA%E5%BA%8F.png" alt="alt text"></li>
</ol>
</li>
<li>为类的对象分配内存：<br>  当类已被加载，会为类的对象分配内存，相当于在内存空间中为类的划分出一块空间，算法有指针碰撞法和空闲列表法。<ol>
<li>指针碰撞：<br> 需要内存空间规整的情况，即GC算法需要整理内存空间。<br> 算法过程： 指针处于已分配内存和未分配内存分界线处，向未分配内存移动，直到分配到足够多的内存即停止。</li>
<li>空闲列表：<br> 在虚拟机中维护一个空闲列表，用来记录堆中哪些内存是未分配的，在为对象分配内存的时候，会从列表中找到合适大小的内存块。</li>
</ol>
</li>
<li>初始化零值<br>  会为分配的内存初始化零值，所以新创建的对象的字段都是有默认值的。</li>
<li>执行对象的初始化方法</li>
<li>创建引用，入栈（被操作）</li>
</ol>
<p>对象如何访问到呢？</p>
<ol>
<li>使用句柄：先去句柄池中找到指向对象实例数据的指针，和指向对象类型数据的指针，再分别去找对应的类型数据。</li>
<li>直接指针：对象的实例数据可以直接访问到，但对象的类型数据是先找到指针，再找对应的类型数据。</li>
</ol>
</li>
<li><p>JVM内存模型是什么样的？<br>   JVM内存分为堆、方法区（JDK7是永久代，JKD8中变成了元空间，处于本地内存中）、线程私有区域、本地内存。<br>   <strong>线程私有区域</strong>里有虚拟机栈、本地方法栈、程序计数器。虚拟机栈里的栈帧有局部变量、操作数栈、方法返回地址、动态链接（是为了把符号引用转化为直接引用）。<br>   <strong>堆</strong>里是线程共享的，几乎所有的对象都在这里分配，并且GC管理的区域就是这里。这里在JDK7及以前，分为新生代、老年代和永久代。JDK8之后，永久代变成了元空间并且放到了本地内存中。<br>   <strong>方法区：</strong>主要存储类信息、字段信息、常量和静态变量。方法区像是接口，而JDK7的实现为永久代，JDK8实现为元空间。<br>   <strong>本地内存：</strong>就是本机内存，不是JVM划分出来的内存，<strong>直接内存</strong>就是jvm直接映射空间到本地内存，可以直接操控，在零拷贝里有应用。</p>
<ul>
<li>JDK1.7：<br><img src="/%E9%9D%A2%E8%AF%95/JVM%E5%86%85%E5%AD%98JDK7.png" alt="alt text"></li>
<li>JDK1.8<br><img src="/%E9%9D%A2%E8%AF%95/JVM%E5%86%85%E5%AD%98JDK8.png" alt="alt text"></li>
</ul>
</li>
<li><p>什么时候对象会加载？</p>
<ol>
<li>使用new创建对象实例的时候。</li>
<li>使用反射，如Class.forName()、newInstance()的时候。</li>
<li>当初始化一个类，而其有父类并且未初始化的时候，会先初始化父类。</li>
<li>main()方法所在的类，在JVM启动的时候会被加载、初始化。</li>
</ol>
</li>
<li><p>双亲委派机制？有什么优点？打破双亲委派机制？自定义类加载器？<br>双亲委派机制是jvm的一个加载类的机制。<br>首先，jvm他有三个类加载器，启动类加载器、扩展类加载器、应用程序类加载器，类加载的时候，先从应用程序类加载器开始，先判断这个类是否被该类加载器加载过，如果不是，则加载任务委派给父类加载器，父类加载器进行同样的操作，最多委派到启动类加载器，启动类加载器会尝试加载类，如果这个类不属于他加载，则返回到扩展类加载器，同样判断，最后返回到应用程序类加载器。在这期间，类要不被加载，要不最后返回错误。</p>
<p>优点：</p>
<ol>
<li>避免了类被重复加载</li>
<li>安全性</li>
</ol>
<p>怎么打破双亲委派机制？自定义类加载器？<br>自定义类加载器，去基础ClassLoader这个类，去重写loadClass方法。<br>Tomcat，他通过自定义的类加载器，实现了web应用之间的隔离。</p>
</li>
<li><p>接口和抽象类的区别</p>
<ol>
<li>一个类只能继承一个抽象类，但能实现多个接口</li>
<li>接口的方法都是抽象方法，而抽象类给可以给方法具体的实现。</li>
<li>接口是对局部行为进行抽象，而抽象类是对类整体进行抽象。</li>
</ol>
</li>
<li><p>JVM 调优？如何定位当前系统的瓶颈？</p>
<ol>
<li><p><strong>监控资源使用情况</strong>：</p>
<ul>
<li>检查CPU、内存、磁盘I&#x2F;O和网络I&#x2F;O的使用情况。使用工具如<code>top</code>, <code>htop</code>, <code>vmstat</code>, <code>iostat</code>等。</li>
</ul>
</li>
<li><p>查看<strong>运行日志</strong>，去看具体哪部分的问题。</p>
</li>
<li><p><strong>查看Java进程的线程状态</strong>：</p>
<ul>
<li>使用arthas这些工具来获取线程的堆栈跟踪，分析是否有线程处于等待状态，或者是否有死锁。</li>
</ul>
</li>
<li><p><strong>分析GC（垃圾回收）日志</strong>：</p>
<ul>
<li>检查GC日志文件，确定是否有频繁的GC发生，这可能是内存不足或GC配置不当的信号。</li>
</ul>
</li>
<li><p><strong>分析代码性能</strong>：<br>审查代码，查看是否有地方使用低效的算法。</p>
</li>
<li><p><strong>网络问题排查</strong>：</p>
<ul>
<li>如果应用需要频繁的网络通信，检查网络延迟和带宽使用情况。</li>
</ul>
</li>
<li><p><strong>配置优化</strong>：</p>
<ul>
<li>根据监控结果调整JVM参数，如堆大小、栈大小、GC算法等。</li>
</ul>
</li>
</ol>
</li>
</ol>
<h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><ol>
<li>java的异常体系<br>java的异常体系最顶层是throwable类，他有两个子类，exception和error。<ul>
<li>error：表示的是运行时错误，而且是应用程序无法解决的错误。</li>
<li>exception：<ul>
<li>非运行时异常：在编译期间就会被发现并报错</li>
<li>运行时异常：是应用程序可以自己处理的异常</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><ol start="6">
<li>常用的集合？底层原理？<ol>
<li><p><strong>HashMap:</strong><br><br><strong>在JDK1.8之前，</strong>HashMap的底层是由数组加链表组成的链表散列。<br>Key在通过哈希计算并经过扰动处理后得到hash值，然后去找到数组对应的位置，判断该位置是否存在元素，如果存在，则判断是否是同一个元素，如果是，则覆盖，否则把数据存储在链表的头部。</p>
<p><strong>在JDK1.8之后，</strong>HashMap的底层是由数组、链表和红黑树组成的，当链表的长度超过阈值后，如果数组长度小于64，则先进行扩容，如果大于64了，则把链表转化为红黑树。</p>
<p>HashMap有几个构造方法，最重要的参数是负载因子和初始大小。默认的HashMap大小为16，且大小必须是2的幂次，如果传入10，则最终大小是16；而负载因子为0.75，这表示当数组只能存放 n*0.75个元素（n表示数组长度），如果超过这个大小，则会扩容。</p>
<p><strong>为什么大小必须是2的幂次？</strong><br>因为2的N次幂有助于减少碰撞，而且使用了速度更快的位运算（&amp;(n-1)操作）来替换了取模运算，而只有大小为2的幂次的时候，它们俩才相等。</p>
<p><strong>负载因子的大小有什么讲究吗？</strong><br>负载因子太小，则会导致数组浪费，而太大，则会导致过多的碰撞。</p>
<p><strong>HashMap是线程安全的吗？有什么问题？</strong><br><br>不是线程安全的，在JDK1.7的时候，多线程情况下，扩容会导致链表死循环和数据丢失的情况。<br>而在jdk1.8的时候，put方法会出现数据覆盖的情况。</p>
<p><strong>put方法：</strong></p>
<ol>
<li>首先根据 key 的值计算 hash 值，找到该元素在数组中存储的下标；</li>
<li>如果没有哈希冲突直接放在对应的数组下标里；</li>
<li>如果冲突了，且 key 已经存在，就覆盖掉 value；</li>
<li>如果冲突后，发现该节点是红黑树，就将这个节点挂在树上；</li>
<li>如果冲突后是链表，判断该链表是否大于 8 ，如果大于 8 并且数组容量小于 64，就进行扩容；如果链表节点大于 8 并且数组的容量大于 64，则将这个结构转换为红黑树；否则，链表插入键值对，若 key 存在，就覆盖掉 value。<br><img src="/%E9%9D%A2%E8%AF%95/HashMap%E7%9A%84PUT.png" alt="alt text"></li>
</ol>
<p><strong>get方法：</strong></p>
<ol>
<li>对key做hash运算，计算index</li>
<li>找数组中对应的位置，如果是单个元素并且key相等，则返回元素，如果为空，则返回null（getOrDefault()可以指定）</li>
<li>如果是链表节点，则遍历链表找到目标节点并返回</li>
<li>如果是树节点，则查找树节点<br><strong>扩容resize方法：</strong></li>
<li>在元素个数大于阈值，即数组长度✖负载因子后，进行扩容，数组长度变为原来的2倍。</li>
<li>准备新的数组，然后把旧的数据重新hash计算，并放到对应的位置。<br><strong>一般用什么作为HashMap的key?</strong><br>一般用Integer、String 这种不可变类当作 HashMap 的 key，String 最为常见。</li>
</ol>
<ul>
<li>因为字符串是不可变的，所以在它创建的时候 hashcode 就被缓存了，不需要重新计算。</li>
<li>因为获取对象的时候要用到 equals() 和 hashCode() 方法，那么键对象正确的重写这两个方法是非常重要的。Integer、String 这些类已经很规范的重写了 hashCode() 以及 equals() 方法</li>
</ul>
<h4 id="为什么string和integer是不可变的？什么是不可变类？"><a href="#为什么string和integer是不可变的？什么是不可变类？" class="headerlink" title="为什么string和integer是不可变的？什么是不可变类？"></a>为什么string和integer是不可变的？什么是不可变类？</h4><h4 id="hashSet是如何实现查重的？"><a href="#hashSet是如何实现查重的？" class="headerlink" title="hashSet是如何实现查重的？"></a>hashSet是如何实现查重的？</h4><p>hashSet底层调用的是HashMap的put方法，它实际上不管元素是否已经存在，都是直接覆盖的，只不过会返回一个Boolean，告诉我们之前是否存在这个值，如果是true，则存在，否则，不存在。</p>
<h4 id="比较-HashSet、LinkedHashSet-和-TreeSet-三者的异同"><a href="#比较-HashSet、LinkedHashSet-和-TreeSet-三者的异同" class="headerlink" title="比较 HashSet、LinkedHashSet 和 TreeSet 三者的异同"></a>比较 HashSet、LinkedHashSet 和 TreeSet 三者的异同</h4><p><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/2348753">https://cloud.tencent.com/developer/article/2348753</a></p>
</li>
<li><p>ArrayList与LinkedList</p>
<p><strong>ArrayList</strong>是能自动扩容的数组，底层是Object数组。在添加元素之前都会判断是否需要扩容。<br><strong>可以添加null吗？</strong> 可以，但不建议，容易出现空指针异常。<br><strong>扩容机制：</strong><br></p>
<ol>
<li>无参构造方法会创建一个容量为0的数组，第一次添加元素的时候，会扩容为10。</li>
<li>使用有参构造可以指定数组容量。</li>
<li>在每一次添加元素的时候，都会判断是否需要扩容，即元素数目是否已经和数组容量相同了。如果是，则扩容为1.5倍。</li>
</ol>
<h3 id="arrayList怎么实现线程安全？"><a href="#arrayList怎么实现线程安全？" class="headerlink" title="arrayList怎么实现线程安全？"></a>arrayList怎么实现线程安全？</h3><ol>
<li>使用synchronized，加锁</li>
<li>使用Collections.synchronizedList，就是在内部使用了synchronized</li>
<li>使用CopyOnWriteArrayList，是写时复制，在每次写操作，都会复制一次数组，所以在写操作较多的情况下，性能很差。</li>
</ol>
<p><strong>LinkedList</strong> 底层由双向链表实现。 在头尾操作节点的情况下，复杂度为O(1)，但是其他地方，复杂度为O(n)。</p>
<p>两者对于内存的占用，arraylist主要是末尾的数组不会被使用，浪费了，而linkedList则是prev和next指针会消耗空间。</p>
</li>
<li><p>ConcurrentHashMap<br>ConcurrentHashMap是线程安全的HashMap，它并非锁住整个方法，而是通过原子操作和局部加锁的方法保证了多线程的线程安全，且尽可能减少了性能损耗。<br><strong>JDK1.7</strong>的版本，ConcurrentHashMap是由Segment数组结构和HashEntry数组结构组成的，HashEntry存储的是键值对数据，而Segment是一个可重入锁，继承了ReentrantLock。segment是一个分段锁，每个segment里包含了一个HashEntry数组，每个HashEntry存储了一部分的hash范围的数据。每次修改数据必须得获得对应的segment锁。<br><img src="/%E9%9D%A2%E8%AF%95/ConcurrentHashMap%20JDK7.png" alt="alt text"><br><strong>JDK1.8中</strong>，ConcurrentHashMap 选择了与 HashMap 相同的数组+链表+红黑树结构，在锁的实现上，采用 CAS 操作和 synchronized 锁实现更加低粒度的锁，只需要锁住这个链表的首节点，并不会影响其他的 数组 元素的读写，大大提高了并发度。<br><img src="/%E9%9D%A2%E8%AF%95/ConcurrentHashMap%20JDK8.png" alt="alt text"><br><strong>那为什么 JDK1.8 要使用 synchronized 锁而不是其他锁呢？</strong><br><br>因为synchronized在jdk8的时候得到了极大的优化，并且有多种锁状态，会从无锁-&gt;可重入锁-&gt;轻量级锁-&gt;重量级锁根据情况逐渐升级，性能高了很多。<br><strong>put方法：</strong><br>JDK1.7:<br><br>先尝试自旋获取锁，如果自旋重试的次数超过 64 次，则改为阻塞获取锁。获取到锁后：</p>
<ol>
<li>将当前 Segment 中的 数组中 通过 key 的 hashcode 定位到 对应的HashEntry。</li>
<li>遍历该 HashEntry，如果不为空则判断传入的 key 和当前遍历的 key 是否相等，相等则覆盖旧的 value。</li>
<li>不为空则需要新建一个 HashEntry 并加入到 Segment 中，同时会先判断是否需要扩容。</li>
<li>释放 Segment 的锁<br>JDK1.8:<br><br>先定位到 Node，拿到首节点 first，判断是否为：</li>
<li>如果为 null ，通过 CAS 的方式把数据 put 进去。</li>
<li>如果不为 null ，并且其他线程在扩容，参与一起扩容。</li>
<li>如果不为 null ，并且没有其他线程在扩容，则synchronized 锁住 first 节点，判断是链表还是红黑树，遍历插入。<br><strong>为什么 ConcurrentHashMap 的 key 和 value 不能为 null？</strong><br><br>这是因为当通过 get(k) 获取对应的 value 时，如果获取到的是 null 时，无法判断，它是 put(k,v) 的时候 value 为 null，还是这个 key 从来没有添加。</li>
</ol>
<p><strong>ConcurrentHashMap和HashMap加锁有什么区别？</strong><br>8. 锁的粒度，CouncurrentHashMap的锁粒度更细，性能更好<br>9. 乐观锁，CouncurrentHashMap的锁大量使用CAS操作，而synchronized和reentrantLock是悲观锁。（synchronized会锁升级，最后会升级为重量级锁）<br>10. 安全性：CouncurrentHashMap是经过精心设计的，保证了并发安全，而使用Synchronized和reentrantLock可能会出现并发安全的问题。</p>
</li>
<li><p>LinkedHashMap<br>LinkedHashMap底层结构是数组+链表&#x2F;红黑树+双向链表，它在HashMap 基础上在各个节点之间维护一条双向链表，使得原本散列在不同 bucket 上的节点、链表、红黑树有序关联起来。<br><img src="/%E9%9D%A2%E8%AF%95/LinkedHashMap.png" alt="alt text"><br>LinkedHashMap有一个accessOrder属性，如果为true，排序模型为 访问顺序， 如果为false，则为 插入顺序。<br>插入顺序就是节点被添加的顺序，而访问顺序则是把访问到的数据放到双向队列的末尾。<br><strong>如何实现LRU缓存？</strong><br>利用LinkedHashMap，设置accessOrder为true，则排序模型为访问顺序。每次访问的节点都会被放到链表末尾，所以链表头的节点是最近最少使用的节点。</p>
</li>
<li><p>TreeMap<br>红黑树实现的Map，可以保持数据的自然顺序，或者自定义comparator排序。<br><strong>红黑树（英语：Red–black tree）是一种自平衡的二叉查找树（Binary Search Tree），结构复杂，但却有着良好的性能，完成查找、插入和删除的时间复杂度均为 log(n)。</strong></p>
</li>
<li><p>PriorityQueue<br>PriorityQueue是一个优先级队列，是一个无界队列，即队列的容量可以无限扩充。它是线程不安全的，不支持null元素。<br>它的底层是一个完全二叉树。</p>
</li>
</ol>
</li>
</ol>
<h2 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h2><ol start="7">
<li><p>进程间通信的方式？</p>
<ol>
<li>管道（匿名管道）：它只适用于有亲缘关系的进程间通信，而且是单向的，半双工。</li>
<li>有名管道：也是半双工的，但是适合于任何进程间的通信。</li>
<li>消息队列：是消息的链表，在内核中。</li>
<li>共享内存：就是一个进程创建一块能被其他进程访问的内存空间。</li>
<li>信号量：一个计数器，常用于锁，实现进程间的同步。</li>
<li>套接字Socket：可以用于两个机器间的通信。</li>
<li>信号signal：给某个进程发送某个信号，如kill信号。</li>
</ol>
</li>
<li><p>线程间通信的方式</p>
<ol>
<li>volatile：用volatile修饰变量，会让线程每次都去共享空间中读取最新的变量值，保证了变量的可见性。</li>
<li>synchronized：给临界区加锁，只有获得锁的线程才能访问临界区资源。</li>
<li>ReentrantLock：与synchronized类似，只不过实现方式不同。</li>
<li>信号量</li>
<li>如果说同步方式的话，原子类是否也算？</li>
</ol>
</li>
<li><p>为什么需要Java内存模型？<br>由于多核CPU的多级缓存的存在，会导致多线程并发情况下，缓存不一致性的问题。又因为不同的CPU和操作系统的内存模型各不相同，Java为了屏蔽硬件和操作系统访问内存的各种差异，提出了「Java内存模型」的规范，保证了Java程序在各种平台下对内存的访问都能得到一致效果。</p>
</li>
<li><p>Java内存模型是什么？<br>是一种规范，主要分成三块:</p>
<ol>
<li>Java内存模型的抽象结构<br>每个线程都有自己的本地内存，以及一个公共的共享内存。<br><img src="/%E9%9D%A2%E8%AF%95/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.png" alt="alt text"></li>
<li>happen-before规则<br>  happen-before实际上也是一套「规则」。Java内存模型定义了这套规则，目的是为了阐述「操作之间」的内存「可见性。<br>  总结起来就两条：</li>
</ol>
<ul>
<li>只要不影响单线程、多线程执行结果，怎么指令重排、怎么优化都可以</li>
<li>只要会影响执行结果，就必须禁止</li>
</ul>
<ol start="3">
<li>volatile<br>  volatile通过禁止重排，可以保证有序性和可见性。</li>
</ol>
</li>
<li><p>并发编程的三个重要特性：</p>
<ol>
<li>原子性：一个操作或多个操作要么全部执行，要么全都不执行</li>
<li>可见性：一个线程对变量的修改，其他线程要立即能看到修改后的新值</li>
<li>有序性：不能因为指令重排导致代码的执行顺序被改变了</li>
</ol>
</li>
<li><p>线程池的参数？<br><strong>最重要的三个参数</strong>:</p>
<ol>
<li>corePoolSize：核心线程数目，即阻塞队列没有达到上限的时候，最多同时运行的线程数目</li>
<li>maximumPoolSize：在任务队列满了之后，线程池最大能同时运行的线程数目</li>
<li>workQueue：如果当线程数目已经到达corePoolSize，则新任务会被放入任务队列<br><strong>其他常见参数</strong>:</li>
<li>keepAliveTime：当线程数超过了核心线程数，非核心线程在没有任务的情况下，持续多久才被销毁</li>
<li>threadFactory：可以在创建新线程的时候给线程添加名字</li>
<li>handler：饱和策略，如果任务队列满了，并且线程数已经到达了最大线程数，线程池采取的策略。比如 抛出异常来拒绝新任务、直接抛弃、丢弃最早的未处理的任务等。</li>
</ol>
</li>
<li><p>线程池创建两种方式？底层原理？</p>
<h3 id="创建方式："><a href="#创建方式：" class="headerlink" title="创建方式："></a>创建方式：</h3><ol>
<li>通过Executors 创建，但是不推荐，因为它创建的任务队列都是无界或者容量为Integer.MAX_VALUE，很容易造成OOM。</li>
<li>通过ThreadPoolExecutor，推荐，可以指定上述的各种参数。<br><strong>线程池的最佳实践：</strong></li>
<li>声明线程池的时候，一定要用有界队列，避免OOM。</li>
<li>可以线程池的一些现成的API来监控线程池的情况，比如线程数目、任务队列长度等。</li>
<li>不同业务的线程池尽量分开。</li>
<li>CPU密集型，核心线程数N+1，I&#x2F;O密集型，2*N</li>
</ol>
<h3 id="线程池的底层原理："><a href="#线程池的底层原理：" class="headerlink" title="线程池的底层原理："></a>线程池的底层原理：</h3><ol>
<li>线程池可以理解为一个集合，一般使用ArrayList、HashSet、LinkedList等。</li>
<li>一般使用LinkedList<Thread>来作为容器。</li>
<li>第一次启动时，创建多个线程，保存到一个集合中。</li>
<li>使用线程时，就从集合中取出线程使用。<br>如：Thread t &#x3D; list.remove(0);<br>Thread t &#x3D; linked.removeFirst();</li>
<li>使用完线程，则把线程归还到 集合中。（集合一般是队列，先进先出）</li>
</ol>
</li>
<li><p>什么是公平锁，什么是非公平锁？synchronized是公平的吗？为什么？<br><strong>公平锁：</strong> 就是先尝试获取锁的线程肯定会比后尝试获取锁的线程 先获得锁，类似于FIFO。<br><strong>非公平锁：</strong> 就是不能按照先来后到的顺序获得锁。<br>synchronized的是非公平锁，因为synchronized无论处于哪个级别，比如无锁、偏向锁、轻量级锁、重量级锁，其中除了偏向锁，每个线程都是会尝试去抢占锁。</p>
</li>
<li><p>synchronized是怎么升级锁的？</p>
<ol>
<li>无锁：无锁状态，不涉及到多线程的竞争访问。</li>
<li>偏向锁：<br>  核心思想：共享资源被第一次访问时候，该线程的ID会被锁记录在结构中，之后该线程获取锁将直接获取，不需要任何同步操作。<br><br>  加锁的时候，可以通过CAS操作去记录线程ID，存放在锁的结构中。<br><br>  偏向锁是最乐观的锁，这样做是假设资源在大部分情况下，只有一个线程访问，很少出现并发冲突的情况。<br></li>
<li>轻量级锁：<br>  当出现线程并发冲突的时候，偏向锁会升级为轻量级锁。线程通过CAS操作去获取锁，如果自旋次数超过一定次数，则升级为重量级锁。</li>
<li>重量级锁：<br>  重量级锁依赖于操作系统底层的mutex操作，需要状态切换，消耗资源较多。</li>
</ol>
</li>
<li><p>ReentrantLock 是什么？<br>ReentrantLock是一个可重入且独占式的锁，和synchronized类似，但是更灵活、强大，增加了轮询、超时、中断、公平锁和非公平锁等高级功能。底层是AQS实现的。</p>
<h3 id="reentrantLock是如何实现公平锁和非公平锁的？"><a href="#reentrantLock是如何实现公平锁和非公平锁的？" class="headerlink" title="reentrantLock是如何实现公平锁和非公平锁的？"></a>reentrantLock是如何实现公平锁和非公平锁的？</h3><ol>
<li>先解释公平锁和非公平锁。</li>
<li>reentrantLock默认是非公平锁。对于公平锁的实现，reentrantLock内部是用一个双向队列实现的，新来的线程，会进入队列，在队列末尾等待前一个节点释放锁。而非公平锁，会在一开始尝试去竞争锁，如果失败，会和公平锁一样，放到队列末尾。</li>
<li>非公平锁的性能比公平锁要高，因为公平锁中，线程在获取不到锁的情况下，会进入休眠状态，当他成为首节点后，又会从休眠态切换到运行态，而状态的切换需要内核状态的切换。这就导致性能较低。<br>  而非公平锁，在线程最开始尝试竞争锁的时候，可能直接获得锁，这就避免了两次内核切换，从而导致性能的提升。</li>
</ol>
</li>
<li><p>synchronized 和 ReentrantLock 有什么区别？</p>
<ol>
<li>两者都是可重入锁：可重入锁是一个线程持有一个锁的情况下，可以在没有释放锁的情况下再次获取该锁。</li>
<li>synchronized依赖于JVM，而ReentrantLock是依赖于JDK。</li>
<li>ReentrantLock 比 synchronized 增加了一些高级功能</li>
<li>等待可中断：ReentrantLock可以在获取锁的时候，选择放弃等待。而synchronized不行</li>
<li>ReentrantLock可以指定是公平锁还是非公平锁。而synchronized只能是非公平锁。</li>
</ol>
</li>
<li><p>ThreadLocal是什么？可以用来做什么？底层是什么？（<strong>需要更详细点</strong>）<br><strong>是什么：</strong> 使用ThreadLocal可以为变量在每个线程中都创建副本，这样就能隔绝其他线程的干扰。<br><strong>用来做什么：</strong> 1. 用来做线程间数据隔离 2. Session会话管理，如果一个连接用一个线程，则可以用ThreadLocal来保存session。<br><strong>底层是什么：</strong> </p>
<ol>
<li>每个thread内部有一个Map，ThreadLocalMap</li>
<li>Map里面存储的key是ThreadLocal实例对象，value是变量的副本</li>
<li>Thread内部的Map是由ThreadLocal来维护的，通过ThreadLocal负责获取和设置线程中ThreadLocalMap的变量值</li>
<li>对于不同的线程，只能获取到它自己的ThreadLocalMap中的value值，这样就隔离了不同线程<br><img src="/%E9%9D%A2%E8%AF%95/threadlocal.png" alt="alt text"></li>
</ol>
<h4 id="ThreadLocal的set方法："><a href="#ThreadLocal的set方法：" class="headerlink" title="ThreadLocal的set方法："></a>ThreadLocal的set方法：</h4><ol start="5">
<li>获取当前线程，并从当前线程中获取ThreadLocals属性，ThreadLocals就是ThreadLocalMap</li>
<li>判断ThreadLocalMap是否为null</li>
<li>如果非null，则在map中新增key-value</li>
<li>否则创建map，同时新增key-value (thread.threadLocals&#x3D;new ThreadLocalMap(this, firstValue))， 这里的this指的是调用方法的ThreadLocal</li>
</ol>
<h4 id="ThreadLocal的get方法："><a href="#ThreadLocal的get方法：" class="headerlink" title="ThreadLocal的get方法："></a>ThreadLocal的get方法：</h4><ol start="9">
<li>获取当前线程，并从当前线程中获取ThreadLocals属性，ThreadLocals就是ThreadLocalMap</li>
<li>如果map不为null，以当前的threadLocal为key，获取副本变量entry</li>
<li>如果变量entry不为空，则强转其value为需要的类型，并返回</li>
<li>如果map不存在，或者map存在，但threadLocal对应的entry为null，则调用setInitialValue()。setInitialValue()方法主要就是为key-value的value赋初值，同时判断Map是否存在，如果不存在则创建。<br><strong>总结：</strong> 先获取当前线程的ThreadLocalMap变量，如果存在则返回值，不存在则创建并返回初始值。</li>
</ol>
<h4 id="ThreadLocal的remove方法："><a href="#ThreadLocal的remove方法：" class="headerlink" title="ThreadLocal的remove方法："></a>ThreadLocal的remove方法：</h4><ol start="13">
<li>获取当前线程，并从当前线程中获取ThreadLocals属性，ThreadLocals就是ThreadLocalMap</li>
<li>如果map不为null，则以调用remove方法的ThreadLocal为key删除对应的实体entry</li>
</ol>
<p><strong>ThreadLocalMap中的key是强引用会导致什么问题？</strong><br>15. 当在业务代码中使用完ThreadLocal，ThreadLocal Ref被回收了<br>16. 但是由于在ThreadLocalMap中的entry强引用了threadLocal，则造成了threadLocal无法被回收。<br>17. 如果没有手动调用remove方法，并且线程还在运行，则引用链current thread ref-&gt; current thread-&gt; map-&gt; entry会导致entry无法被回收，从而导致内部的<strong>key和value</strong>无法回收，出现内存泄漏的情况。<br><img src="/%E9%9D%A2%E8%AF%95/ThreadLocal%E5%BC%BA%E5%BC%95%E7%94%A8.png" alt="alt text"></p>
<p><strong>ThreadLocalMap中的key是弱引用会怎么样？</strong><br>18. 当在业务代码中使用完ThreadLocal，ThreadLocal Ref被回收了<br>19. 由于entry是弱引用指向threadlocal，所以threadlocal会被回收，key此时值为null<br>20. 如果没有手动调用remove方法，并且线程还在运行，则引用链current thread ref-&gt; current thread-&gt; map-&gt; entry会导致entry无法被回收，从而导致内部的<strong>value</strong>无法回收，出现内存泄漏的情况。<br><img src="/%E9%9D%A2%E8%AF%95/ThreadLocal%E5%BC%B1%E5%BC%95%E7%94%A8.png" alt="alt text"></p>
<p><strong>出现内存泄漏的真实原因：</strong><br>无论是强引用还是弱引用都会出现内存泄漏的问题。</p>
<h4 id="出现内存泄漏的前提："><a href="#出现内存泄漏的前提：" class="headerlink" title="出现内存泄漏的前提："></a>出现内存泄漏的前提：</h4><ol start="21">
<li>没有手动删除entry</li>
<li>currentThread依然运行<br>所以根本原因是threadLocalMap的生命周期和current thread一样长，如果没有手动删除对应的key就会导致内存泄漏。</li>
</ol>
<p><strong>那为什么要用弱引用？</strong><br>要避免内存泄漏有以下两种方法：<br>23. 使用完threadLocal，调用其remove()方法<br>24. 使用完threadLocal，线程随之结束<br>相较于第一种方法，第二种更不好控制，例如在线程池的情况下，核心线程是不会销毁的。</p>
<p>也就是说，只要及时调用**remove()**方法，无论key是强引用还是弱引用都不会有问题，那为什么要用弱引用呢？</p>
<p>事实上，threadLocalMap的get&#x2F;set方法，会对key为null进行判断，如果为null，那么会把value置为null。</p>
<p>这样就多了一层保障，即使忘记调用remove()，<strong>弱引用</strong>的threadLocal会被回收，而value会在下次map调用get&#x2F;set方法的时候被置为null，避免了内存泄漏。</p>
<p><strong>ThreadLocal如何解决hash冲突的？</strong><br>ThreadLocal使用的线性探测法来解决hash冲突，流程如下：<br>25. 先根据key来计算索引i，然后查找位置i上的entry<br>26. 若是entry已经存在并且key等于传入的key，那么覆盖旧值<br>27. 若是遇到key为null，则替换这个空的entry<br>28. 不断向后探测，直到遍历索引i后面所有的节点直至遇到null，如果一直没有找到合适的位置，则在末尾新建一个entry，并把size+1 (哈希表是一个循环数组)<br>29. 如果size到达阈值，则进行扩容和rehash</p>
<p><strong>threadLocal为什么一般设置为static？</strong><br>避免重复创建TSO（Thread Specific Object，即ThreadLocal所关联的对象）所导致的浪费。  </p>
<p>设置为static可以让多个线程共享这个ThreadLocal变量，同时由于ThreadLocal的作用，多个线程之间又能互相隔离，这样减少了每个线程单独创建ThreadLocal的消耗。否则，每次创建一个对应的类实例，ThreadLocal就会被创建一次。</p>
</li>
<li><p>AQS是什么？</p>
<ol>
<li>首先，了解CLH锁：<br><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/jEx-4XhNGOFdCo4Nou5tqg">https://mp.weixin.qq.com/s/jEx-4XhNGOFdCo4Nou5tqg</a></li>
</ol>
<p>AQO是在CLH锁的基础上进行了改进得到的。</p>
</li>
<li><p>future是什么？你对它的理解<br><strong>future介绍：</strong><br>当我们执行某一耗时的任务时，可以将这个耗时任务交给一个子线程去异步执行，同时我们可以干点其他事情，不用傻傻等待耗时任务执行完成。等我们的事情干完后，我们再通过 Future 类获取到耗时任务的执行结果。这样，程序的执行效率就显著提高了。</p>
<p>这其实就是多线程中经典的 Future 模式，你可以将其看作是一种<strong>设计模式</strong>，<strong>核心思想</strong>是异步调用，主要用在多线程领域，并非 Java 语言独有。<br>future有五个方法：</p>
<ol>
<li>boolean cancel(boolean mayInterruptIfRunning)：尝试取消执行任务。</li>
<li>boolean isCancelled()：判断任务是否被取消。</li>
<li>boolean isDone()：判断任务是否已经被执行完成。</li>
<li>get()：等待任务执行完成并获取运算结果。</li>
<li>get(long timeout, TimeUnit unit)：多了一个超时时间。<br><strong>future有些缺陷：</strong></li>
</ol>
</li>
<li><p>countdownLatch是什么？<br>它是一个同步工具类，通过一个计数器来实现，初始值为线程的数量，当一个线程完成了它的任务，就会让计数器减一，当计数器的值为0，则说明所有线程任务都已完成，这样等待的线程就可以继续往下执行。<br><strong>有两个应用场景：</strong></p>
<ol>
<li>某个线程需要等待多个线程都完成某一任务</li>
<li>需要多个线程同时执行某个任务，通过处理速度<br><strong>项目中CountDownLatch的使用方法：</strong></li>
</ol>
<h4 id="第一种：CountDownLatch配合线程池："><a href="#第一种：CountDownLatch配合线程池：" class="headerlink" title="第一种：CountDownLatch配合线程池："></a>第一种：CountDownLatch配合线程池：</h4><ol start="3">
<li>在一次HBase的查询中，把生成的get的list列表，依据指定的列表长度，拆分成多个小列表，然后交给线程池进行查询。</li>
<li>此时，由于当前线程需要等到所有查询线程返回结果后，才能进一步处理。所以，在最开始new一个CountDownLatch对象，其值为get拆分成的小list的个数，并调用CountDownLatch.await()，当然要指定超时时间。</li>
<li>而每个查询线程在执行完任务，或者出现异常的时候，都会将CountDownLatch的值减一，直到CountDownLatch的值为0，此时主线程结束等待，执行接下来的任务。</li>
</ol>
<h4 id="第二种：CountDownLatch配合future、线程池："><a href="#第二种：CountDownLatch配合future、线程池：" class="headerlink" title="第二种：CountDownLatch配合future、线程池："></a>第二种：CountDownLatch配合future、线程池：</h4><ol start="6">
<li>事先new一个Map，key为特定的值，比如如果要查询当前数据和上周数据，key会是current和lastWeek，value为future。然后在线程池中提交任务的时候，在map中保存每一个返回的future，</li>
<li>主线程会调用CountDownLatch.await()，设置超时时间。之后，会遍历这个Map，调用future的isDone()方法，判断是否完成任务，是，就调用future.get()方法得到结果，并放入返回的结果中，否则，在返回结果中放入一个空值。</li>
</ol>
</li>
</ol>
<h2 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h2><ol>
<li><p>什么是垃圾回收？什么时候会触发垃圾回收？<br>垃圾回收是Java虚拟机的一种机制，它会自动地回收那些不被使用的对象，释放空间，不像c++那样需要手动释放内存。</p>
<p>触发垃圾回收需要首先了解jvm的内存结构，几乎所有的对象都存在堆中，而jvm把堆分成了新生代、老年代和永久代（JDK7及之前），新生代又被分为Eden区和survivor区，survivor区又被分为s1和s0。<br><strong>什么时候触发垃圾回收？</strong><br><br>垃圾回收分为minor gc和full gc。</p>
<p>新对象被创建的时候都会被分配到Eden区，如果Eden区空间满了，则会触发一次minor GC，它会尝试把Eden区中的对象转移到s0或s1，与此同时，如果s0被标记为from，那它会把eden区的对象和s0的对象都转移到s1中，并且对象的年龄均加一，然后标记s1为from，并把s0清空。如果有对象年龄超过了阈值，则会把它转移到老年代中。此时，它会通过分配担保机制把新生代的对象转移到老年代中。</p>
<p><strong>分配担保机制：</strong><br><br>在minor GC之前，虚拟机会检查老年代的可用空间是否大于新生代所有对象的空间之和。<br>如果大于，则是安全的<br>否则，看虚拟机的参数是否设置了允许担保失败，如果是，则查看老年代的空间是否大于历次晋升到老年代的空间的平均大小，如果是，虽然不安全，但会尝试minor gc，否则进行full gc。</p>
<p><strong>minor gc和full gc的差别？</strong><br></p>
<ol>
<li>minor gc作用于新生代，比较频繁，回收速度也比较快。</li>
<li>full gc作用于老年代，一般full gc会伴随一次minor gc。full gc的速度一般比minor gc慢10倍。</li>
</ol>
<p><strong>什么时候触发full gc？</strong><br></p>
<ol>
<li>在minor gc的时候，老年代没有足够的空间分配给新生代晋升的对象</li>
<li>堆中产生大对象，会直接进入老年代，但此时老年代如果空间不够，则会触发full gc</li>
<li>调用System.gc，建议系统使用full gc，但不一定执行</li>
</ol>
</li>
<li><p>怎么判断哪些对象要被回收？</p>
<ol>
<li><p>引用计数法<br>对象每增加一个引用，则计数+1，每次有一个引用失效，则计数-1，如果计数为0，则会被回收<br>缺点： 无法很好地解决循环引用的问题</p>
</li>
<li><p>可达性分析法<br>从GC roots出发，如果无法找到一条路径到对象，则该对象会被回收。</p>
<p>GC roots一般是活跃的引用，比如虚拟机栈中栈帧的局部变量、静态变量等。</p>
</li>
</ol>
<p><strong>引用的类型？</strong></p>
<ol>
<li>强引用：当内存空间不足，Java虚拟机宁愿抛出OutOfMemoryError错误，使程序异常终止，也不回收这种对象。</li>
<li>软引用：对于软引用关联着的对象，只有在内存不足的时候JVM才会回收该对象。</li>
<li>弱引用：被软引用关联的对象只有在内存不足时才会被回收，而被弱引用关联的对象在JVM进行垃圾回收时总会被回收。</li>
<li>虚引用：它并不影响对象的生命周期，在任何时候都可能被垃圾回收器回收。</li>
</ol>
</li>
<li><p>回收算法有哪些？</p>
<ol>
<li>标记-清除算法：先标记出所有不需要回收的对象，然后再删除没有被标记的对象。<br><strong>问题：</strong> 大量的内存碎片</li>
<li>标记-复制算法：把空间分成两半，一半使用，一半备用。把存活的对象复制到另一半空间，然后当前的空间释放。<br><strong>问题：</strong> 浪费空间，并且复制大对象性能较差。</li>
<li>标记-整理算法：把所有被标记的对象都往一端移动，剩下的空间被释放。<br><strong>问题：</strong> 多了整理这一步，性能较差，但适合老年代这些不常整理的空间。</li>
</ol>
<p>由于各个方法都有缺陷，所以使用了分代收集算法。</p>
</li>
<li><p>垃圾回收器有哪些？</p>
<ol>
<li><p>serial收集器：新生代使用标记-复制，老年代使用标记-整理。最大的特点就是单线程，无论是新生代的回收还是老年代的回收，都是单线程，而且要停止用户线程。</p>
</li>
<li><p>parNew收集器：与serai类似，只是在新生代回收这里是多线程回收，而且暂停用户线程。</p>
</li>
<li><p>parallel scavenge收集器：与parNew几乎一样，但是在老年代回收是多线程的。</p>
</li>
<li><p>serial Old收集器：作为serial收集器的老年代版本</p>
</li>
<li><p>parallel old：parallel scavenge的老年代版本。</p>
</li>
<li><p>CMS收集器：它关注于让用户线程的停顿最短，最注重用户体验。是HotSpot虚拟机真正意义上第一款并发收集器，它第一次实现了让<strong>垃圾收集线程</strong>与<strong>用户线程</strong>（基本上）同时工作。<br>使用的是<strong>标记-清除</strong>算法，整体分为四个步骤：</p>
<ol>
<li>初始标记：暂停所有的其他线程，并记录下直接与 root 相连的对象，速度很快 ；</li>
<li>并发标记：同时开启 GC 和用户线程，记录可达对象；</li>
<li>重新标记：重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶段时间短。<strong>此时用户线程会暂停。</strong></li>
<li>并发清除： 开启用户线程，同时 GC 线程开始对未标记的区域做清扫。<br>缺点：因为使用标记-清除，会导致大量的内存碎片。而且有些垃圾会无法清理。</li>
</ol>
</li>
<li><p>G1收集器：是一款面向服务器的垃圾收集器<br>优点：</p>
<ol>
<li>并行与并发：实现了垃圾回收线程和用户线程的并行</li>
<li>空间整合：从整体上看是 标记-整理 算法，从局部看是 标记-复制算法。</li>
<li>可以预测的停顿：用户可以建立一个可以预测的时间停顿模型。<br>步骤：</li>
<li>初始标记</li>
<li>并发标记</li>
<li>最终标记</li>
<li>筛选回收<br><img src="/%E9%9D%A2%E8%AF%95/G1%E6%B5%81%E7%A8%8B.png" alt="alt text"></li>
</ol>
<p>G1 收集器在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的 Region(这也就是它的名字 Garbage-First 的由来) 。这种使用 Region 划分内存空间以及有优先级的区域回收方式，保证了 G1 收集器在有限时间内可以尽可能高的收集效率（把内存化整为零）。</p>
</li>
</ol>
</li>
</ol>
<h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><ol>
<li>设计模式六大原则<ol>
<li>开闭原则<br>对扩展开放，对修改关闭。</li>
<li>里氏代换原则<br>任何父类可以出现的地方，子类一定可以出现。也就是说父类有的功能，子类要有，父类没有的功能，子类可以扩展。</li>
<li>依赖倒转原则<br>实现的细节依赖于抽象，有点像面向接口编程，在顶层设计好之后，再去设计细节的代码结构。</li>
<li>接口隔离原则<br>使用多个隔离的接口，要优于一个综合的接口。能降低耦合度。</li>
<li>最少知道原则<br>一个实体应当尽量少的与其他实体之间发生相互作用，使得模块之间互相独立。</li>
<li>合成复用原则<br>应当尽量使用合成&#x2F;聚合的方式达到复用的目的，而非继承。<br><strong>合成：</strong>表示整体和部分的关系，整体和部分不能分开。多个对象组合在一起成为一个整体，而分开则不能存在。也就是说，整体消亡，部分也消亡。<br><strong>聚合：</strong>就像一辆车，轮胎可以分开单独存在，也就是说整体和部分可以分开。部分不随着整体的消亡而消亡。</li>
</ol>
</li>
<li>设计模式：<h3 id="创建型模式"><a href="#创建型模式" class="headerlink" title="创建型模式"></a>创建型模式</h3><ol>
<li>工厂模式：就是写一个工厂类，它来负责具体的类的实例化，传入类的类型，然后返回该类的实例对象。<br>优点：<ol>
<li>主要是解耦了，不需要自己new对象，而是通过调用同一个方法来生成不同的对象 </li>
<li>可以只写一个工厂类，来实现很多类的实例化，减少代码量<br>缺点：如果要扩展程序，比如需要更多的类，则需要修改工厂类，新增if-else代码，违反开闭原则了。</li>
</ol>
</li>
<li>抽象工厂模式： 有一个抽象的超级工厂类，它将产品分组，每一组有一个对应的工厂类。<br>优点：<ol>
<li>这样写符合开闭原则。</li>
<li>让系统的整体结构更加清晰<br>缺点：<br>   如果要改动，新增类工厂，则很麻烦。</li>
</ol>
</li>
<li>单例模式<br>预加载和懒加载两种</li>
<li>建造者模式（构建者模式）<br>实现一个抽象的builder、具体的builder，以及一个director，director调用具体的创建者，去创建产品product，而具体创建者builder实现抽象创建者builder的方法。</li>
<li>原型模式<br>原型模式（Prototype Pattern）是用于创建重复的对象，同时又能保证性能。<br>具体来说，就是通过拷贝原来的对象，生成一个新的对象。</li>
</ol>
<h3 id="结构型模式"><a href="#结构型模式" class="headerlink" title="结构型模式"></a>结构型模式</h3><ol>
<li>适配器模式：通俗来讲，就是通过一个类 转换 两个不兼容的接口，这样隐藏了复杂的转换细节。</li>
<li>装饰器模式：装饰器模式（Decorator Pattern）允许向一个现有的对象添加新的功能，同时又不改变其结构。</li>
<li>代理模式：创建一个类，去代理另一个类，主要是为了控制被代理类的行为。<br><strong>代理模式与装饰器模式的区别：</strong><br>装饰器模式强调的是增强，是 在被装饰者的基础上拓展功能，容易扩展，而代理模式，则是强调控制被代理者，不容易扩展。</li>
</ol>
<h3 id="行为型模式"><a href="#行为型模式" class="headerlink" title="行为型模式"></a>行为型模式</h3><ol>
<li>观察者模式<br>定义对象间的一种 一对多 的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。</li>
<li>责任链模式<br>把多个接收者组织成一条链，对于每一个请求，沿着这条链传递，直到遇到第一个可以处理该请求的接收者。<br>好处：可以把发送者、请求者之间有效地解耦。</li>
</ol>
</li>
</ol>
<h3 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h3><ol>
<li><p>JDK序列化的底层原理<br>JDK自带的序列化方式，需要实现Serializable接口，这个接口没有定义任何方法和属性，只起到<strong>标识</strong>作用，表示这个类是可以被序列化的。<br>JDK的序列化方式主要通过输出流java.io.ObjectOutputStream和对象输入流java.io.ObjectInputStream来实现。</p>
<h4 id="具体过程："><a href="#具体过程：" class="headerlink" title="具体过程："></a>具体过程：</h4><p><strong>序列化：</strong> 当调用ObjectOutputStream的writeObject()时，JVM 会检查被序列化的对象是否实现了 Serializable 接口。如果没有实现，则抛出NotSerializableException异常。如果实现了 Serializable 接口，则 JVM 会通过反射机制获取对象的类结构，并将其转换为字节流。<br><strong>反序列化：</strong> 当调用ObjectInputStream的readObject()方法时，JVM 会读取字节流并还原成 Java 对象。在此过程中，JVM 会使用反射机制创建对象，并通过反射设置对象的属性值。</p>
<p><strong>静态变量会被序列化吗？</strong><br>序列化是针对对象的，而非针对类，而静态变量属于类，所以不会被序列化。<br><strong>怎么指定字段不要被序列化？</strong><br>用transient关键字修饰字段，序列化的时候会自动忽略。<br><strong>父类会被序列化吗？</strong><br>如果B类继承了A类，序列化B类的时候会序列化A类（前提是A类也实现了Serializable接口）。</p>
<p>不被序列化的属性，在反序列化的时候会被赋值为null。</p>
<p><strong>SerialVersionUID有什么作用？</strong><br>Java的序列化机制是通过判断类的serialVersionUID来验证版本一致性的。</p>
<p>在进行反序列化时，JVM会把传来的字节流中的serialVersionUID与本地相应实体类的serialVersionUID进行比较，如果相同就认为是一致的，可以进行反序列化，否则就会出现序列化版本不一致的异常，即是InvalidCastException。</p>
<p><strong>当要反序列化的类被修改了，JVM在反序列化的时候发现serialVersionUID被改变了，报错了，那该怎么办？</strong><br>如果没有手动指定serialVersionUID，那在修改类的字段和方法的时候，jvm会自动改变serialVersionUID。<br>所以，我们指定serialVersionUID为一个固定值，那么修改了字段和方法的时候，serialVersionUID不会变化，在反序列化的时候也就不会报错了。</p>
<p><strong>Externalizable接口知道吗？</strong><br>Serializable 接口内部序列化是 JVM 自动实现的，如果我们想自定义序列化过程，就可以使用Externalizable接口。</p>
</li>
</ol>
<!-- flag of hidden posts -->
    </div>

    
    
    

    <footer class="post-footer">

        

    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">hhubibi</span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/mist/" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script>

  






  





</body>
</html>
